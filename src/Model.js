/*
This file was generated by https://github.com/pmndrs/gltfjsx and then
customized manually. It uses drei's new useAnimations hook which extracts
all actions and sets up a THREE.AnimationMixer for it so that you don't have to.
All of the assets actions, action-names and clips are available in its output.
*/

import React, { useEffect, useState, useMemo } from "react"
import { useGLTF, useFBX, useTexture, useCursor, useAnimations } from "@react-three/drei"
import { useGraph } from "@react-three/fiber"
import { a, useSpring } from "@react-spring/three"
import { SkeletonUtils } from "three-stdlib"

export default function Model({ pose, ...props }) {
  // Fetch FBX model
  const fbx = useFBX("/Silly Dancing.fbx")

  // Clone the FBX for safe usage (FBX models need cloning for reuse)
  const clone = useMemo(() => SkeletonUtils.clone(fbx), [fbx])

  // Extract animation actions from the FBX
  const { ref, actions, names } = useAnimations(fbx.animations, clone)

  // Hover and animation-index states
  const [hovered, setHovered] = useState(false)
  const [index, setIndex] = useState(pose || 0)

  // Animate the selection halo
  const { color, scale } = useSpring({
    scale: hovered ? [1.15, 1.15, 1] : [1, 1, 1],
    color: hovered ? "hotpink" : "aquamarine"
  })

  // Change cursor on hover-state
  useCursor(hovered)

  // Enable shadows on all meshes
  useEffect(() => {
    if (clone) {
      clone.traverse((child) => {
        if (child.isMesh) {
          child.castShadow = true
          child.receiveShadow = true
        }
      })
    }
  }, [clone])

  // Change animation when the index changes
  useEffect(() => {
    // Reset and fade in animation after an index has been changed
    console.log(`Available animations: ${names}`)
    console.log(`Current index: ${index}`)
    console.log(`Available actions:`, Object.keys(actions))

    if (names.length > 0 && index >= 0 && index < names.length && actions[names[index]]) {
      actions[names[index]].reset().fadeIn(0.5).play()
      // In the clean-up phase, fade it out
      return () => actions[names[index]].fadeOut(0.5)
    }
  }, [index, actions, names])

  return (
    <a.group
      ref={ref}
      {...props}
      scale={scale}
      onPointerOver={() => setHovered(true)}
      onPointerOut={() => setHovered(false)}
      onClick={() => setIndex((index + 1) % names.length)}>
      <primitive object={clone} />
    </a.group>
  )
}
